/*******************************************************************************************
* Programmer: Kevin Rogers                                                                        *
* Class: Cpt S 223, Spring 2013                                              *
* Programming Assignment: PA4                                                       *
* Date: April 24, 2013                                                                            *
* Description: This program can either create a randomly generated maze or read a maze from a text file.
               It then continues to solve the maze in two different methods and prints the solution.         *
*******************************************************************************************/

#include "DisjSet.h"

int main(int argc, char* argv[])
{
	int size=0;
	int random=0;
	int szsqr=0;
	int row=0;
	int column=0;
	int cellNum=0;
	boardCell cell;
	vector<vector<boardCell>> board;

	if(argc > 1)
	{

		ifstream myfile;

		myfile.open(argv[1]);


		myfile>>size;

		int i = 0;
		int j = 0;
		int RoomNum = 0;

		while(i < size)
		{
			vector<boardCell> row;

			while(j < size)
			{
				boardCell temp;
				int input;

				myfile>>input;
				temp.asgUp(input);

				myfile>>input;
				temp.asgDown(input);

				myfile>>input;
				temp.asgRight(input);

				myfile>>input;
				temp.asgLeft(input);

				temp.asgcellNum(RoomNum);
				RoomNum++;

				row.push_back(temp);

				j++;
			}
		j = 0;
		board.push_back(row);
		i++;
		}
	
		printBoard(board,size);

		vector<vector<boardCell>> board2 = board;
		solveBFT(board,size);
		solveDFT(board2,size);

		system("pause");
	}

	else
	{
	//For a randomly generated maze this is the number of rows and columns input by user//
	cout<<"Please enter n for your nxn maze: ";
	cin>>size;

	//Initializes a disjoint set based on the size of the maze//
	DisjSets s(size*size);

	

	int i = 0;
	int j = 0;

	//Creates a grid that is the appropriate size with all walls intitially up//
	for(j=0;j<size;j++)
	{
		vector<boardCell> length;

		for(i=0;i<size;i++)
		{
			length.push_back(cell);
			length[i].asgcellNum(cellNum);
			cellNum++;
		}

		board.push_back(length);
	}

/////////////////////////////////////////////////////////

	//Creates the maze within the board so that there is a solution to the maze//
	initializeBoard(board,size,s);


/////////////////////////////////////////////////////////

	//Prints the board that is generated by initializeBoard//
	printBoard(board,size);

////////////////////////////////////////////////////////////	

	//Solve the random maze by using a queue and broad search algorithm//
	vector<vector<boardCell>> board3 = board;
	solveBFT(board,size);
	solveDFT(board3,size);


    system("pause");
	}

	return 0;
}